{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/robertifpb/AlgoritmosPY/blob/main/chat_p2p.py\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "qXBxtCuhnRkg"
      },
      "source": [
        "Chat P2P com Sockets TCP e Threads"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "reqHi3odWhHT"
      },
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "4s_W1_56nIBA"
      },
      "outputs": [],
      "source": [
        "import socket\n",
        "import threading\n",
        "import time\n",
        "from datetime import datetime\n",
        "\n",
        "#Topo com informações do projeto prático\n",
        "textoSaudacao = [\n",
        "    '*' * 100,\n",
        "    f\"{'bem vindo ao chat p2p com sockets tcp e threads' .upper():^100}\",\n",
        "    f\"{'protocolos e interconecção de redes de computadores' .upper():^100}\",\n",
        "    '*' * 100\n",
        "]\n",
        "\n",
        "#Uso da função .join para concatenar elementos da lista (textoSadudacao)\n",
        "print('\\n'.join(textoSaudacao))\n",
        "time.sleep(2)\n",
        "\n",
        "#Portas disponiveis simuladas\n",
        "portas_disponiveis = [5000, 5001, 5002, 5003, 5004]\n",
        "\n",
        "#Mensagem de boas vindas\n",
        "solicita_usuario = [\n",
        "    f\"{'Abaixo informe os dados para realizar a conexão'.center(100)}\"\n",
        "]\n",
        "\n",
        "#Exibindo a mensagem de boas vindas antes das portas disponíveis\n",
        "print('\\n'.join(solicita_usuario))\n",
        "\n",
        "#Exibindo as portas simuladas disponíveis\n",
        "print(\"\\nPortas disponíveis para uso na conexão: \")\n",
        "\n",
        "for porta in portas_disponiveis:\n",
        "  print(f\" - {porta}\")\n",
        "\n",
        "#Solicita informações para conexão do usuário com validação da porta\n",
        "nome = input(\"\\nNome do usuário: \")\n",
        "\n",
        "while True:\n",
        "    try:\n",
        "        porta_usuario = int(input(f\"{nome}, escolha uma porta da lista: \"))\n",
        "        if porta_usuario in portas_disponiveis:\n",
        "            break\n",
        "        else:\n",
        "            print(\"Porta inválida. Tente novamente.\")\n",
        "    except ValueError:\n",
        "        print(\"Por favor, insira um número válido.\")\n",
        "\n",
        "#Exibe a informação do usuário e porta conectada\n",
        "print(f\"\\nUsuário {nome} escolheu a porta {porta_usuario}.\")\n",
        "\n",
        "# Inicializa conexões\n",
        "conexoes = []\n",
        "\n",
        "#Peers conectados\n",
        "todos_peers = [('localhost', p) for p in portas_disponiveis if p != porta_usuario]\n",
        "\n",
        "#Criando servidor e tornando acessível á todos\n",
        "servidor = None\n",
        "\n",
        "#Executando o servidor\n",
        "def executando():\n",
        "  global servidor\n",
        "  servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
        "  servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n",
        "  servidor.bind(('localhost', porta_usuario))\n",
        "  servidor.listen(10)\n",
        "  print(f\"[{nome}] Executando em localhost: {porta_usuario} ...\")\n",
        "  time.sleep(2)\n",
        "  while True:\n",
        "    try:\n",
        "      conn, addr = servidor.accept()\n",
        "      conexoes.append(conn)\n",
        "      threading.Thread(target=recebimento_mensagens, args=(conn,), daemon=True).start()\n",
        "      registro_logs(f\"[ENTRADA USR] Conexão recebida de {addr}\")\n",
        "\n",
        "    except OSError:\n",
        "      break #Fecha servidor e sai do loop\n",
        "\n",
        "#Decodificação das mensagens recebidas\n",
        "def recebimento_mensagens(conn):\n",
        "  while True:\n",
        "    try:\n",
        "      dados = conn.recv(1024)\n",
        "      if not dados:\n",
        "        break\n",
        "      mensagem = dados.decode('utf-8')\n",
        "      # Exibe a mensagem recebida (uma vez)\n",
        "      print(\"\\n\" + mensagem)\n",
        "      #Registro de logs de mensagens recebidas\n",
        "      registro_logs(f\"[MSG RECEBIDA] {mensagem}\")\n",
        "\n",
        "    except ConnectionResetError:\n",
        "      break\n",
        "\n",
        "#Conecção dos peer e exibindo conexões ativas\n",
        "def conectar_peers():\n",
        "  while True:\n",
        "    for ip, porta in todos_peers:\n",
        "      try:\n",
        "        if any(conn.getpeername()[1] == porta for conn in conexoes if isinstance(conn, socket.socket)):\n",
        "          continue\n",
        "      except OSError:\n",
        "        pass\n",
        "\n",
        "      try:\n",
        "        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
        "        s.connect((ip, porta))\n",
        "        conexoes.append(s)\n",
        "        print(f\"\\t[{nome}] Conectado com sucesso!\\n\\tIP DE PEER: [{ip}]\\n\\tPORTA DE CONEXÃO: [{porta}]\")\n",
        "        print(f\"[INFO] Total de conexões ativas: {len(conexoes)}\")\n",
        "        registro_logs(f\"[USR CONECTADO] Conectado ao peer na porta {porta}\")\n",
        "\n",
        "      except:\n",
        "           pass\n",
        "\n",
        "    time.sleep(5)\n",
        "\n",
        "#Decodificação das mensagens enviadas\n",
        "def enviar_mensagens(msg):\n",
        "  for conn in list(conexoes):\n",
        "      try:\n",
        "        conn.send(f\"{nome}: {msg}\".encode('utf-8'))\n",
        "        registro_logs(f\"[MSG ENVIADA] {nome}: {msg}\")\n",
        "\n",
        "      except:\n",
        "          try:\n",
        "              conexoes.remove(conn)\n",
        "          except:\n",
        "              pass\n",
        "\n",
        "#Registro de logs\n",
        "def registro_logs(mensagem):\n",
        "    timestamp = datetime.now().strftime(\"[%d/%m/%Y %H:%M:%S]\")\n",
        "    with open(\"logs_chat.txt\", \"a\", encoding=\"utf-8\") as arquivo:\n",
        "        arquivo.write(f\"{timestamp} {mensagem}\\n\")\n",
        "\n",
        "#Informa quando usuário sai do chat\n",
        "def avisar_saida_usuario():\n",
        "  mensagem_saida = f\"{nome} saiu do chat!\"\n",
        "  #registra a saída no log\n",
        "  registro_logs(f\"[INF SAIDA] {nome}, encerrou o chat.\")\n",
        "  for conn in list(conexoes):\n",
        "    try:\n",
        "      conn.send(mensagem_saida.encode('utf-8'))\n",
        "    except:\n",
        "      pass\n",
        "\n",
        "# Fecha as conexões com os peers\n",
        "def encerrar_conexao():\n",
        "  for conn in list(conexoes):\n",
        "      try:\n",
        "          conn.close()\n",
        "      except:\n",
        "          pass\n",
        "\n",
        "# Função para encerrar o programa corretamente\n",
        "def finalizar():\n",
        "    print(\"Encerrando o chat...\")\n",
        "    avisar_saida_usuario()\n",
        "    time.sleep(2)  # aguarda enviar mensagens e gravar logs\n",
        "    print(f\"{nome}, chat encerrado, consulte o log para informações das conexões.\")\n",
        "\n",
        "    if servidor:\n",
        "        try:\n",
        "            servidor.close()\n",
        "        except:\n",
        "            pass\n",
        "\n",
        "    encerrar_conexao()\n",
        "\n",
        "#Executando as Threads em segundo plano\n",
        "threading.Thread(target=executando, daemon=True).start()\n",
        "threading.Thread(target=conectar_peers, daemon=True).start()\n",
        "\n",
        "#Loop principal protegido para garantir encerramento\n",
        "try:\n",
        "    while True:\n",
        "        texto = input()\n",
        "        if texto.strip().lower() == \"sair\":\n",
        "            break\n",
        "        enviar_mensagens(texto)\n",
        "        print(f\"Você ({nome}): {texto}\")\n",
        "finally:\n",
        "    finalizar()\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "Th9l_YL-z_eb"
      },
      "outputs": [],
      "source": []
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "id": "47RvLCc0N8VP"
      },
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "authorship_tag": "ABX9TyO0Sg1dp+BBz4pLcqHz32fH",
      "include_colab_link": true
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}